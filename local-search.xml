<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>表格跨行、跨列操作</title>
    <link href="/2022/05/20/%E8%A1%A8%E6%A0%BC%E8%B7%A8%E8%A1%8C%E3%80%81%E8%B7%A8%E5%88%97%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/05/20/%E8%A1%A8%E6%A0%BC%E8%B7%A8%E8%A1%8C%E3%80%81%E8%B7%A8%E5%88%97%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>在操纵数据表格时，不免会有需要出现跨行，跨列的操作。这里操作表格的HTML的原生方法</p><p>一般使用&lt;td&gt;元素的colspan属性来实现单元格跨列操作，使用&lt;td&gt;元素的rowspan属性来实现单元格的跨行操作。<br>he<br>colspan属性规定单元格可横跨的列数，所有浏览器都支持colspan属性。其取值为number，如下图所示：</p><p><img src="/img/tableRow/image_vvQUDgW4oK.png"></p><p>下面是这个属性的例子和结果的截图。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期一<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>星期二<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>星期天<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/tableRow/image_F3UTSPquqt.png"></p><p>rowspan属性规定单元格可横跨的行数，所有浏览器都支持rowspan属性。其取值为number，需要注意的是和上面一样rowspan&#x3D;”0”指示浏览器横跨到表格部分的最后一行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>星期一<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>星期二<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>星期三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/img/tableRow/image_DPq4B97yFb.png"></p><h2 id="el-table的跨行方法"><a href="#el-table的跨行方法" class="headerlink" title="el-table的跨行方法"></a>el-table的跨行方法</h2><p>上面介绍了原生的colspan和rowspan方法。但是我们最常用的不是原生的方法而是各种组件库，上面的各种方法也只是让大家认识一下colspan和rowspan属性和他们的作用而已。</p><p>通过给<code>el-table</code>传入<code>span-method</code>方法可以实现合并行或列，方法的参数是一个对象，里面包含当前行<code>row</code>、当前列<code>column</code>、当前行号<code>rowIndex</code>、当前列号<code>columnIndex</code>四个属性。该函数可以返回一个包含两个元素的数组，第一个元素代表<code>rowspan</code>，第二个元素代表<code>colspan</code>。 也可以返回一个键名为<code>rowspan</code>和<code>colspan</code>的对象。</p><p>具体的例子如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-attr">arraySpanMethod</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">&#123; row, column, rowIndex, columnIndex &#125;</span>) &#123;<br>        <span class="hljs-keyword">if</span>(row.<span class="hljs-property">id</span>==<span class="hljs-string">&#x27;平均工号&#x27;</span>)&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(column)<br>          <span class="hljs-keyword">if</span>(column.<span class="hljs-property">label</span>==<span class="hljs-string">&#x27;ID&#x27;</span>)&#123;<br>              <span class="hljs-keyword">return</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br>          &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(column.<span class="hljs-property">label</span>==<span class="hljs-string">&#x27;姓名&#x27;</span>)&#123;<br>              <span class="hljs-keyword">return</span> [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]<br>          &#125;<br>        &#125;  <br>    &#125;,<br></code></pre></td></tr></table></figure><p>最后的效果如下：</p><p><img src="/img/tableRow/image_EsDyuRAXcy.png"></p><p>需要注意的有两点，一是el-table没有原生表格那种单元格的概念（当然在底层实现有的），所以我们需要传入四个参数“定位”单元格，然后返回一个[<code>rowspan</code>, <code>colspan</code>]的数组或是对象。分别代表在行和列上分别占了几个单元格。二是这里的rowspan和colspan的值，1是代表单元格本身的长度，而0是代表没有长度，这里和原生的地方有区别需要注意一下。</p>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web前端</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3中的setup语法糖</title>
    <link href="/2022/05/20/setup%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <url>/2022/05/20/setup%E8%AF%AD%E6%B3%95%E7%B3%96/</url>
    
    <content type="html"><![CDATA[<h2 id="setup语法糖"><a href="#setup语法糖" class="headerlink" title="setup语法糖"></a>setup语法糖</h2><p>最开始的时候，Vue3的暴露变量必须要<code>return</code>出来，才可以在<code>template</code>中使用。但实话实说这种写法不是很友好。在一个文件中会<code>return</code>多次，同时在写代码时要时刻关注该变量是否暴露，造成了许多麻烦。vue3.2只需在script标签中添加setup，可以帮我们解决这个问题。</p><p>组件只需引入不用注册，属性和方法也不用返回，也不用写setup函数，也不用写export default ，甚至是自定义指令也可以在我们的template中自动获得。下面是一个例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;home&quot;&gt;<br>    显示的值：&#123;&#123;flag &#125;&#125;<br>    &lt;button @click=&quot;changeHander&quot;&gt;改变值&lt;/button&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script setup&gt;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>let flag = ref(&quot;开端-第一次循环&quot;)<br><br>function changeHander()&#123;<br>  flag.value=&#x27;第二次有什么不好的&#x27;  <br>&#125;<br>&lt;/script&gt;<br><br><br></code></pre></td></tr></table></figure><h2 id="组件无需注册"><a href="#组件无需注册" class="headerlink" title="组件无需注册"></a>组件无需注册</h2><p>在Vue3.2中组件在引入之后无需注册，SFC文件会自动将其注册。同时当组件没有<code>name</code>属性时，vue会自动用文件名充当name属性，以后也就是不用再写name属性了。下面是代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 这个是子组件 --&gt;<br>&lt;template&gt;<br>    &lt;div&gt;<br>      &lt;h2&gt; 你好-我是肖鹤云&lt;/h2&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;!-- 这个是父组件 --&gt;<br>&lt;template&gt;<br>  &lt;div class=&quot;home&quot;&gt;<br>    &lt;test-com&gt;&lt;/test-com&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script lang=&quot;ts&quot; setup&gt;<br>// 组件命名采用的是大驼峰，引入后不需要在注册，是不是爽歪歪呀!<br>//在使用的使用直接是小写和横杠的方式连接 test-com<br>import TestCom from &quot;../components/TestCom.vue&quot;<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h2 id="defineProps的使用"><a href="#defineProps的使用" class="headerlink" title="defineProps的使用"></a>defineProps的使用</h2><p>但是不用setup函数，意味着我们不能使用Vue3原先基于setup函数的父子组件传值方法。但是没关系Vue使用了新的API来让父子组件可以传值。</p><p>父组件传递参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id=&quot;home&quot;&gt;<br>    &lt;HelloWorld :info=&quot;msg&quot; time=&quot;42分钟&quot;&gt;&lt;/HelloWorld&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;<br>import &#123; ref &#125; from &#x27;vue&#x27;<br><br>let msg = ref(&#x27;公交车-第一次循环&#x27;)<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>#home&#123;<br>  text-align: center;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>子组件接受参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;!-- 这个是组件 --&gt;<br>&lt;template&gt;<br>    &lt;div&gt;<br>      &lt;h2&gt; 你好-我是Loopers&lt;/h2&gt;<br>      &lt;p&gt;信息:&#123;&#123; info&#125;&#125;&lt;/p&gt;<br>      &lt;p&gt;&#123;&#123; time &#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script setup&gt;<br>import &#123;defineProps&#125; from &#x27;vue&#x27; // 最新版SFC中defineProps已经自动引入，无须手动引入也可<br>defineProps(&#123;<br>    info:&#123;<br>        type:String,<br>        default:&#x27;----&#x27;<br>    &#125;,<br>    time:&#123;<br>        type:String,<br>        default:&#x27;0分钟&#x27;<br>    &#125;,<br>&#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h2 id="defineEmits的到来！"><a href="#defineEmits的到来！" class="headerlink" title="defineEmits的到来！"></a>defineEmits的到来！</h2><p>上面我们讲了怎么让父组件给子组件传值，下面自然轮到了父组件给子组件传值。下面是具体的代码：</p><p>子组件传递参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;h2&gt; 你好-我是肖鹤云&lt;/h2&gt;<br>        &lt;button @click=&quot;hander1Click&quot;&gt;新增&lt;/button&gt;<br>        &lt;button @click=&quot;hander2Click&quot;&gt;删除&lt;/button&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup&gt;<br>import &#123;defineEmits&#125; from &#x27;vue&#x27;<br>//  使用defineEmits创建名称，接受一个数组<br>let $myemit=defineEmits([&#x27;myAdd&#x27;,&#x27;myDel&#x27;])<br>let hander1Click=():void=&gt;&#123;<br>    $myemit(&#x27;myAdd&#x27;,&#x27;新增的数据&#x27;)<br>&#125;<br><br>let hander2Click=():void=&gt;&#123;<br>    $myemit(&#x27;myDel&#x27;,&#x27;删除的数据&#x27;)<br>&#125;<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><p>父组件接受参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;home&quot;&gt;<br>    &lt;test-com @myAdd=&quot;myAddHander&quot; @myDel=&#x27;myDelHander&#x27;&gt;&lt;/test-com&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script lang=&quot;ts&quot; setup&gt;<br>// 组件命名采用的是大驼峰，引入后不需要在注册，是不是爽歪歪呀!<br>//在使用的使用直接是小写和横杠的方式连接 test-com<br>import TestCom from &quot;../components/TestCom.vue&quot;<br>let myAddHander=(mess):void=&gt;&#123;<br>  console.log(&#x27;新增==&gt;&#x27;,mess);<br>&#125;<br><br>let myDelHander=(mess):void=&gt;&#123;<br>  console.log(&#x27;删除==&gt;&#x27;, mess);<br>&#125;<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h2 id="利用ref获取子组件中的属性值"><a href="#利用ref获取子组件中的属性值" class="headerlink" title="利用ref获取子组件中的属性值"></a>利用ref获取子组件中的属性值</h2><p>在Vue2中我们可以在父组件直接使用<code>$refs</code>来获取子组件的属性和方法。但是这个方法在Vue3中写法与Vue2中完全不同。但是新的语法糖，可以让Vue3用接近Vue2方式来利用ref调用子组件的方法和属性。</p><p>子组件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>    &lt;div&gt;<br>        &lt;h2&gt; 你好-我是肖鹤云&lt;/h2&gt;<br>        &lt;p&gt;性别:&#123;&#123; sex&#125;&#125;&lt;/p&gt;<br>        &lt;p&gt;其他信息:&#123;&#123; info&#125;&#125;&lt;/p&gt;<br>    &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script lang=&quot;ts&quot; setup&gt;<br>import &#123; reactive, ref,defineExpose &#125; from &quot;vue&quot;;<br>let sex=ref(&#x27;男&#x27;)<br>let info=reactive(&#123;<br>    like:&#x27;喜欢李诗晴&#x27;,<br>    age:27<br>&#125;)<br>function aging() &#123;<br>  info.age++<br>&#125;<br>// 将组件中的属性暴露出去，这样父组件可以获取<br>defineExpose(&#123;<br>    sex,<br>    info,<br>    aging<br>&#125;)<br>&lt;/script&gt;<br><br><br></code></pre></td></tr></table></figure><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">test-com</span> @<span class="hljs-attr">myAdd</span>=<span class="hljs-string">&quot;myAddHander&quot;</span> @<span class="hljs-attr">myDel</span>=<span class="hljs-string">&#x27;myDelHander&#x27;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;testcomRef&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">test-com</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getSonHander&quot;</span>&gt;</span>获取子组件中的数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">TestCom</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;../components/TestCom.vue&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;ref&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> testcomRef = <span class="hljs-title function_">ref</span>()</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getSonHander</span>=(<span class="hljs-params"></span>)=&gt;&#123;</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取子组件中的性别&#x27;</span>, testcomRef.<span class="hljs-property">value</span>.<span class="hljs-property">sex</span> );</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;获取子组件中的其他信息&#x27;</span>, testcomRef.<span class="hljs-property">value</span>.<span class="hljs-property">info</span> );</span><br><span class="language-javascript">  testcomRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">aging</span>()</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>上面的代码就演示了利用ref属性来调用子组件的属性和方法。</p><h2 id="新增指令-v-memo"><a href="#新增指令-v-memo" class="headerlink" title="新增指令 v-memo"></a>新增指令 v-memo</h2><p>v-memod会记住一个模板的子树,元素和组件上都可以使用。 该指令接收一个固定长度的数组作为依赖值进行[记忆比对]。 如果数组中的每个值都和上次渲染的时候相同，则整个子树的更新会被跳过。 即使是虚拟 DOM 的 VNode 创建也将被跳过，因为子树的记忆副本可以被重用。 因此渲染的速度会非常的快。 需要注意得是:正确地声明记忆数组是很重要。 开发者有责任指定正确的依赖数组，以避免必要的更新被跳过。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in listArr&quot;</span>  <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>  <span class="hljs-attr">v-memo</span>=<span class="hljs-string">&quot;[&#x27;valueA&#x27;，&#x27;valueB&#x27;]&quot;</span>&gt;</span><br>    &#123;&#123; item.name &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里的<code>v-memo</code>的作用很像React Hooks中useEffect中的<code>deps</code>数组。如果数组不变，那么这个元素或组件就不会重渲染。但是和<code>deps</code>数组一样，可能要考虑数组中含有特殊元素（如函数）的相关情况。这里的具体情况就让我们下次来探究。</p><h2 id="style-v-bind"><a href="#style-v-bind" class="headerlink" title="style v-bind"></a>style v-bind</h2><p>经过尤大佬的不断努力，&lt;style&gt; v-bind 已经从实验室毕业了。我们可以在CSS中使用变量，并且其值可以直接在JS中计算。最先想到的一点就是以后变换角色不用再写多个class了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span> 有开始循环了-开端 <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-tag">span</span> &#123;</span><br><span class="language-css">    <span class="hljs-comment">/* 使用v-bind绑定state中的变量 */</span></span><br><span class="language-css">    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">v-bind</span>(<span class="hljs-string">&#x27;state.color&#x27;</span>);</span><br><span class="language-css">  &#125;  </span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端下载的一些方法</title>
    <link href="/2022/05/20/%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/05/20/%E4%B8%8B%E8%BD%BD%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>最近在项目中遇到了与下载有关的问题，正好总结一下相关的内容。</p><p>如果是本地或同源的资源，直接在<code>a</code>标签中加入<code>downlaod</code>即可。这样不管什么资源都可以直接下载。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;img/1.png&quot;</span> <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;download&quot;</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面是用js直接生成<code>a</code>标签的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>a.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span><br><span class="hljs-keyword">const</span> url = <span class="hljs-string">&#x27;img/1.png&#x27;</span><br>a.<span class="hljs-property">href</span> = url<br>a.<span class="hljs-property">download</span> = <span class="hljs-string">&#x27;download&#x27;</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(a)<br>a.<span class="hljs-title function_">click</span>()<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(a)<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(url)<br></code></pre></td></tr></table></figure><p>但是我们不能什么都下载本地的东西，那样前端会变得很臃肿。这时我们就要用到后端提供的url来进行下载，但是这时候下载url大概率和我们的前端不是同源的，这时下载规则就有一些不一样了。</p><p>当我们下载浏览器不能直接打开的资源时，同源和异源一样。直接<code>a</code>标签上加上<code>download</code>就可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://down1.downxia.com/down/DocX2021a_pan.rar&quot;</span> <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;download&quot;</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>但是当我们要下载图片或者pdf等浏览器可以打开的格式时，加上<code>download</code>属性也会直接用浏览器访问该资源。</p><p>究其原因，<code>download</code>属性仅适用于<a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" title="同源 URL">同源 URL</a>。就算不加上<code>download</code>属性，浏览器无法打开的文件url也会直接下载。但是浏览器可以打开的资源就会直接打开。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.keaidian.com/uploads/allimg/190424/24110307_23.jpg&quot;</span> <span class="hljs-attr">download</span>=<span class="hljs-string">&quot;download&quot;</span>&gt;</span>下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这时想要下载，可以让后端处理。让其对<code>Content-Disposition</code>头进行特殊处理。或者可以请求文件流来直接下载该文件，但需要注意使用文件流，需要先获取全部的文件流，所以并不适合过大的文件。</p><p>利用js下载的代码如下所示，这里请求方式是<code>fetch</code>，但是这个和请求方式无关，想用<code>xhr</code>或者<code>axios</code>都可以进行下载工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> url = <span class="hljs-string">&quot;https://www.keaidian.com/uploads/allimg/190424/24110307_23.jpg&quot;</span><br><span class="hljs-title function_">fetch</span>(url).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> res.<span class="hljs-title function_">blob</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">blob</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>  a.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span><br>  <span class="hljs-keyword">let</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob); <span class="hljs-comment">// 获取 blob 本地文件连接 (blob 为纯二进制对象，不能够直接保存到磁盘上)</span><br>  <span class="hljs-keyword">const</span> filename = <span class="hljs-string">&#x27;download&#x27;</span><br>  a.<span class="hljs-property">href</span> = url;<br>  a.<span class="hljs-property">download</span> = filename;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(a)<br>  a.<span class="hljs-title function_">click</span>();<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(a)<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(url)<br>&#125;));<br></code></pre></td></tr></table></figure><p>需要注意的是就算用了上面这串代码，也无法解决跨域问题。跨域的问题需要去单独解决，不管使用反代理还是要后端去操作。</p>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web前端</tag>
      
      <tag>Javascript</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端中正则表达式的使用</title>
    <link href="/2022/05/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/05/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个字符串是否含有某种子串、将匹配的子串做替换或者从某个字符串中取出符合某个条件的子串等。</p><p>主要用正则表达式来处理字符串，比如验证某个字符串是否符合规定格式，以及快速的格式化某个字符串。</p><p>正则语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs regex">/正则表达式主体/修饰符(可选)<br></code></pre></td></tr></table></figure><h2 id="正则表达式的创建"><a href="#正则表达式的创建" class="headerlink" title="正则表达式的创建"></a>正则表达式的创建</h2><p>在JavaScript中创建正则表达式主要有两种方式：</p><ul><li><p>字面量创建方式</p></li><li><p>实例创建方式</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/pattern/</span>flags<br><span class="hljs-comment">// 字面量创建方式</span><br><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(pattern,flags);<br><span class="hljs-comment">//实例创建方式</span><br><br></code></pre></td></tr></table></figure><p>其中pattern是正则表达式，而flags是标识(修饰符)。</p><p>标识主要包括：</p><ol><li><p>i 忽略大小写匹配</p></li><li><p>&amp;#x20;m 多行匹配，即在到达一行文本末尾时还会继续寻常下一行中是否与正则匹配的项</p></li><li><p>g 全局匹配 模式应用于所有字符串，而非在找到第一个匹配项</p></li></ol><p>而这两种方式的区别主要有这两个：</p><ol><li><p>字面量创建方式不能进行字符串拼接，实例创建方式可以。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regParam = <span class="hljs-string">&#x27;cm&#x27;</span>;<br><span class="hljs-keyword">var</span> reg1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(regParam+<span class="hljs-string">&#x27;1&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1);  <span class="hljs-comment">//   /cm1/</span><br><br></code></pre></td></tr></table></figure></li><li><p>字面量创建方式特殊含义的字符不需要转义，实例创建方式需要转义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;\d&#x27;</span>);  <span class="hljs-comment">//    /d/ </span><br><span class="hljs-keyword">var</span> reg2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;\\d&#x27;</span>)  <span class="hljs-comment">//   /\d/</span><br><span class="hljs-keyword">var</span> reg3 = <span class="hljs-regexp">/\d/</span>;              <span class="hljs-comment">//  /\d/</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>代表特殊含义的元字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs regex">\d : 0-9之间的任意一个数字  \d只占一个位置<br>\w : 数字，字母 ，下划线 0-9 a-z A-Z _<br>\s : 空格或者空白等<br>\D : 除了\d<br>\W : 除了\w<br>\S : 除了\s<br> . : 除了\n之外的任意一个字符<br> \ : 转义字符<br> | : 或者<br>() : 分组<br>\n : 匹配换行符<br>\b : 匹配边界 字符串的开头和结尾 空格的两边都是边界 =&gt; 不占用字符串位数<br> ^ : 限定开始位置 =&gt; 本身不占位置<br> $ : 限定结束位置 =&gt; 本身不占位置<br>[a-z] : 任意字母 []中的表示任意一个都可以<br>[^a-z] : 非字母 []中^代表除了<br>[abc] : abc三个字母中的任何一个 [^abc]除了这三个字母中的任何一个字符<br></code></pre></td></tr></table></figure><p>代表次数的量词元字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs regex">* : 0到多个<br>+ : 1到多个<br>? : 0次或1次 可有可无<br>&#123;n&#125; : 正好n次；<br>&#123;n,&#125; : n到多次<br>&#123;n,m&#125; : n次到m次<br></code></pre></td></tr></table></figure><p>量词出现在元字符后面 如\d+，限定出现在前面的元字符的次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;1223334444&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d&#123;2&#125;/g</span>;<br><span class="hljs-keyword">var</span> res = str.<span class="hljs-title function_">match</span>(reg);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)  <span class="hljs-comment">//[&quot;12&quot;, &quot;23&quot;, &quot;33&quot;, &quot;44&quot;, &quot;44&quot;]</span><br><br><span class="hljs-keyword">var</span> str =<span class="hljs-string">&#x27;  我是空格君  &#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/^\s+|\s+$/g</span>; <span class="hljs-comment">//匹配开头结尾空格</span><br><span class="hljs-keyword">var</span> res = str.<span class="hljs-title function_">replace</span>(reg,<span class="hljs-string">&#x27;&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;(&#x27;</span>+res+<span class="hljs-string">&#x27;)&#x27;</span>)  <span class="hljs-comment">//(我是空格君)</span><br></code></pre></td></tr></table></figure><p>正则中的()和[]和重复子项，拿出来单独说一下。</p><ul><li><p>一般[]中的字符没有特殊含义 如+就表示+，但是像\w这样的还是有特殊含义的</p></li><li><p>[]中，不会出现两位数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">12</span>]表示<span class="hljs-number">1</span>或者<span class="hljs-number">2</span> 不过[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]这样的表示<span class="hljs-number">0</span>到<span class="hljs-number">9</span> [a-z]表示a到z<br>例如:匹配从<span class="hljs-number">18</span>到<span class="hljs-number">65</span>年龄段所有的人<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/[18-65]/</span>; <span class="hljs-comment">// 这样写对么</span><br>reg.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;50&#x27;</span>)<br> <span class="hljs-comment">//Uncaught SyntaxError: Invalid regular expression: /[18-65]/: Range out of order in character class</span><br><span class="hljs-comment">//聪明的你想可能是8-6这里不对，于是改成[16-85]似乎可以匹配16到85的年龄段的，但实际上发现这也是不靠谱的</span><br><br>实际上我们匹配这个<span class="hljs-number">18</span>-<span class="hljs-number">65</span>年龄段的正则我们要拆开来匹配<br>我们拆成<span class="hljs-number">3</span>部分来匹配 <span class="hljs-number">18</span>-<span class="hljs-number">19</span>  <span class="hljs-number">20</span>-<span class="hljs-number">59</span> <span class="hljs-number">60</span>-<span class="hljs-number">65</span> <br>reg = <span class="hljs-regexp">/(18|19)|([2-5]\d)|(6[0-5])/</span>;<br></code></pre></td></tr></table></figure></li><li><p>()的提高优先级功能:凡是有|出现的时候，我们一定要注意是否有必要加上()来提高优先级</p></li><li><p>()的分组 重复子项 (两个放到一起说)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">分组：<br>只要正则中出现了小括号那么就会形成一份分组<br>只要有分组，<span class="hljs-title function_">exec</span>(match)和replace中的结果就会发生改变(后边的正则方法中再说)<br><br>分组的引用(重复子项) :<br>只要在正则中出现了括号就会形成一个分组，我们可以通过\n (n是数字代表的是第几个分组)来引用这个分组，第一个小分组我们可以用\<span class="hljs-number">1</span>来表示<br><br>例如：求出这个字符串<span class="hljs-string">&#x27;abAAbcBCCccdaACBDDabcccddddaab&#x27;</span>中出现最多的字母,并求出出现多少次(忽略大小写)。<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abbbbAAbcBCCccdaACBDDabcccddddaab&#x27;</span>;<br>    str = str.<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)&#123;<span class="hljs-keyword">return</span> a.<span class="hljs-title function_">localeCompare</span>(b)&#125;).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br><br>    <span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(\w)\1+/ig</span>;<br>    <span class="hljs-keyword">var</span> maxStr = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">var</span> maxLen = <span class="hljs-number">0</span>;<br>    str.<span class="hljs-title function_">replace</span>(reg,<span class="hljs-keyword">function</span>(<span class="hljs-params">$<span class="hljs-number">0</span>,$<span class="hljs-number">1</span></span>)&#123;<br>        <span class="hljs-keyword">var</span> regLen = $<span class="hljs-number">0.</span>length;<br>        <span class="hljs-keyword">if</span>(regLen&gt;maxLen)&#123;<br>            maxLen = regLen;<br>            maxStr = $<span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(maxLen == regLen)&#123;<br>            maxStr += $<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`出现最多的字母是<span class="hljs-subst">$&#123;maxStr&#125;</span>,共出现了<span class="hljs-subst">$&#123;maxLen&#125;</span>次`</span>)<br></code></pre></td></tr></table></figure></li><li><p>当我们加()只是为了提高优先级而不想捕获小分组时，可以在()中加?:来取消分组的捕获</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;aaabbb&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(a+)(?:b+)/</span>;<br><span class="hljs-keyword">var</span> res =reg.<span class="hljs-title function_">exec</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br><span class="hljs-comment">//[&quot;aaabbb&quot;, &quot;aaa&quot;, index: 0, input: &quot;aaabbb&quot;]</span><br><span class="hljs-comment">//只捕获第一个小分组的内容</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="正则表达式的优先级"><a href="#正则表达式的优先级" class="headerlink" title="正则表达式的优先级"></a>正则表达式的优先级</h2><ol><li><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p></li><li><p>相同优先级的会从左到右进行运算，不同优先级的运算先高后低。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">下面是常见的运算符的优先级排列<br>依次从最高到最低说明各种正则表达式运算符的优先级顺序：<br><br>\ : 转义符<br>(), (?:), (?=), []  =&gt; 圆括号和方括号<br>*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;   =&gt; 量词限定符<br>^, $, \任何元字符、任何字符 <br>|, =&gt; 替换，<span class="hljs-string">&quot;或&quot;</span>操作<br><br>字符具有高于替换运算符的优先级，一般用 | 的时候，为了提高 | 的优先级，我们常用()来提高优先级<br>如： 匹配 food或者foot的时候 reg = <span class="hljs-regexp">/foo(t|d)/</span> 这样来匹配<br></code></pre></td></tr></table></figure><h2 id="正则的特性"><a href="#正则的特性" class="headerlink" title="正则的特性"></a>正则的特性</h2><ul><li><p>贪婪性：所谓的贪婪性就是正则在捕获时，每一次会尽可能多的去捕获符合条件的内容。 &amp;#x20;<br>如果我们想尽可能的少的去捕获符合条件的字符串的话，可以在量词元字符后加?</p></li><li><p>懒惰性则是正则在成功捕获一次后不管后边的字符串有没有符合条件的都不再捕获。 &amp;#x20;<br>如果想捕获目标中所有符合条件的字符串的话，我们可以用标识符g来标明是全局捕获</p></li></ul><p>这个又贪又懒的特性其实很好理解，下面就是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;123av3423&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d+/</span>;<br><span class="hljs-keyword">var</span> res =reg.<span class="hljs-title function_">exec</span>(str);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// [ &#x27;123&#x27;, index: 0, input: &#x27;123av3423&#x27;, groups: undefined ]</span><br><br>reg = <span class="hljs-regexp">/\d+?/g</span>; <span class="hljs-comment">//解决贪婪性、懒惰性</span><br>res = str.<span class="hljs-title function_">match</span>(reg)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">// [ &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;2&#x27;,&#x27;3&#x27;]</span><br><br></code></pre></td></tr></table></figure><p>在正则表达式加上量词之后，他就会尽可能匹配所有符合条件的字符串，所以最后的结果是123，而不是1或12，这就是贪婪性。如果不在正则表达式后面加上<code>g</code>修饰符，就只会匹配到123为止，而不会匹配后面的3423。这就是正则的懒惰性。最后的代码则是这些方式的解决方法。</p><h2 id="JavaScript中的正则校验方法"><a href="#JavaScript中的正则校验方法" class="headerlink" title="JavaScript中的正则校验方法"></a>JavaScript中的正则校验方法</h2><p>这里我们只介绍test、exec、match和replace这四个方法</p><p>**** 用来验证字符串是否符合正则 符合返回<code>true</code> 否则返回<code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\w+/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(str));  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>**** 用来捕获符合规则的字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc123cba456aaa789&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d+/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">exec</span>(str))<br><span class="hljs-comment">//  [&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;];</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-property">lastIndex</span>)<br><span class="hljs-comment">// lastIndex : 0 </span><br><br>reg.<span class="hljs-property">exec</span>捕获的数组中 <br><span class="hljs-comment">// [0:&quot;123&quot;,index:3,input:&quot;abc123cba456aaa789&quot;]</span><br><span class="hljs-number">0</span>:<span class="hljs-string">&quot;123&quot;</span> 表示我们捕获到的字符串<br><span class="hljs-attr">index</span>:<span class="hljs-number">3</span> 表示捕获开始位置的索引<br>input 表示原有的字符串<br></code></pre></td></tr></table></figure><p>上面的补充，在全新版本的浏览器中，<code>exec</code>捕获的数组会有一个全新的属性<code>groups</code>。这个属性是用来存储命名捕获组的信息。没有分组时，他的值如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;123av3423&#x27;</span>;<br>reg = <span class="hljs-regexp">/\d+?/g</span>;<br>res = reg.<span class="hljs-title function_">exec</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">//[ &#x27;1&#x27;, index: 0, input: &#x27;123av3423&#x27;, groups: undefined ]</span><br></code></pre></td></tr></table></figure><p>当正则规则有分组且分组语法为：<code>(?&lt;捕获组的名字&gt;捕获组对应的规则)</code>，以这种形式来命名。<code>groups</code>这个属性就会返回一个<code>Object</code>，返回了结果分组的详细信息，具体演示如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 命名捕获组的获取</span><br><span class="hljs-keyword">let</span> reg1 = <span class="hljs-regexp">/(?&lt;first&gt;\d)(?&lt;second&gt;\d)/</span><br><span class="hljs-keyword">let</span> str2 = <span class="hljs-string">&#x27;123&#x27;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg1.<span class="hljs-title function_">exec</span>(str2)) <br><span class="hljs-comment">// =&gt;[&#x27;12&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, index: 0, input: &#x27;123&#x27;, groups: &#123; first: &#x27;1&#x27;, second: &#x27;2&#x27; &#125;]而新的语法支持对这些捕获组进行命名，更方便地获取某个捕获组的数据</span><br></code></pre></td></tr></table></figure><p>当我们用exec进行捕获时，如果正则没有加’g’标识符，则exec捕获的每次都是同一个，当正则中有’g’标识符时 捕获的结果就不一样了,我们还是来看刚刚的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc123cba456aaa789&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d+/g</span>;  <span class="hljs-comment">//此时加了标识符g</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-property">lastIndex</span>)<br><span class="hljs-comment">// lastIndex : 0 </span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">exec</span>(str))<br><span class="hljs-comment">//  [&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-property">lastIndex</span>)<br><span class="hljs-comment">// lastIndex : 6</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">exec</span>(str))<br><span class="hljs-comment">// [&quot;456&quot;, index: 9, input: &quot;abc123cba456aaa789&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-property">lastIndex</span>)<br><span class="hljs-comment">// lastIndex : 12</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">exec</span>(str))<br><span class="hljs-comment">// [&quot;789&quot;, index: 15, input: &quot;abc123cba456aaa789&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-property">lastIndex</span>)<br><span class="hljs-comment">// lastIndex : 18</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">exec</span>(str))<br><span class="hljs-comment">// null</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-property">lastIndex</span>)<br><span class="hljs-comment">// lastIndex : 0</span><br><br>每次调用exec方法时,捕获到的字符串都不相同<br>lastIndex ：这个属性记录的就是下一次捕获从哪个索引开始。<br>当未开始捕获时，这个值为<span class="hljs-number">0</span>。          <br>如果当前次捕获结果为<span class="hljs-literal">null</span>。那么lastIndex的值会被修改为<span class="hljs-number">0.</span>下次从头开始捕获。<br>而且这个lastIndex属性还支持人为赋值。<br></code></pre></td></tr></table></figure><p>**** 如果匹配成功，就返回匹配成功的数组，如果匹配不成功，就返回<code>null</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//match和exec的用法差不多</span><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc123cba456aaa789&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d+/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">exec</span>(str));<br><span class="hljs-comment">//[&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg));<br><span class="hljs-comment">//[&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;]</span><br></code></pre></td></tr></table></figure><p>上面的两个字符串不是一模一样吗，但是当我们进行全局匹配时，二者的不同就会显现出来了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc123cba456aaa789&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\d+/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">exec</span>(str));<br><span class="hljs-comment">// [&quot;123&quot;, index: 3, input: &quot;abc123cba456aaa789&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str.<span class="hljs-title function_">match</span>(reg));<br><span class="hljs-comment">// [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;]</span><br></code></pre></td></tr></table></figure><p>当全局匹配时，match方法会一次性把符合匹配条件的字符串全部捕获到数组中, &amp;#x20;<br>如果想用exec来达到同样的效果需要执行多次exec方法。</p><p>此外，match和exec都可以受到分组()的影响，不过match只在没有标识符g的情况下才显示小分组的内容，如果有全局g，则match会一次性全部捕获放到数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(a)(b)(c)/</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( str.<span class="hljs-title function_">match</span>(reg) );<br><span class="hljs-comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, index: 0, input: &quot;abc&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( reg.<span class="hljs-title function_">exec</span>(str) );<br><span class="hljs-comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, index: 0, input: &quot;abc&quot;]</span><br><br><br>当有全局g的情况下<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(a)(b)(c)/g</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( str.<span class="hljs-title function_">match</span>(reg) );<br><span class="hljs-comment">// [&quot;abc&quot;]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( reg.<span class="hljs-title function_">exec</span>(str) );<br><span class="hljs-comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, index: 0, input: &quot;abc&quot;]</span><br></code></pre></td></tr></table></figure><p>**** 这个方法大家肯定不陌生，现在我们要说的就是和这个方法和正则相关的东西了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript">正则去匹配字符串，匹配成功的字符去替换成新的字符串<br>写法：str.<span class="hljs-title function_">replace</span>(reg,newStr);<br><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;a111bc222de&#x27;</span>;<br><span class="hljs-keyword">var</span> res = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\d/g</span>,<span class="hljs-string">&#x27;Q&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br><span class="hljs-comment">// &quot;aQQQbcQQQde&quot;</span><br><br>replace的第二个参数也可以是一个函数<br>str.<span class="hljs-title function_">replace</span>(reg,fn);<br><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;2017-01-06&#x27;</span>;<br>str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/-\d+/g</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>&#125;)<br><br>控制台打印结果：<br>[<span class="hljs-string">&quot;-01&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;2017-01-06&quot;</span>]<br>[<span class="hljs-string">&quot;-06&quot;</span>, <span class="hljs-number">7</span>, <span class="hljs-string">&quot;2017-01-06&quot;</span>]<br><span class="hljs-string">&quot;2017undefinedundefined&quot;</span><br>从打印结果我们发现每一次输出的值似乎跟exec捕获时很相似，既然与exec似乎很相似，那么似乎也可以打印出小分组中的内容喽 <br><br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;2017-01-06&#x27;</span>;<br>str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/-(\d+)/g</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>)<br>&#125;)<br>[<span class="hljs-string">&quot;-01&quot;</span>, <span class="hljs-string">&quot;01&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-string">&quot;2017-01-06&quot;</span>]<br>[<span class="hljs-string">&quot;-06&quot;</span>, <span class="hljs-string">&quot;06&quot;</span>, <span class="hljs-number">7</span>, <span class="hljs-string">&quot;2017-01-06&quot;</span>]<br><span class="hljs-string">&quot;2017undefinedundefined&quot;</span><br>从结果看来我们的猜测没问题。<br><br>此外，我们需要注意的是，如果我们需要替换replace中正则找到的字符串，函数中需要一个返回值去替换正则捕获的内容。<br></code></pre></td></tr></table></figure><p>原文的补充，通过replace方法获取url中的参数的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span>(<span class="hljs-params">pro</span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">queryString</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">var</span> obj = &#123;&#125;,<br>            reg = <span class="hljs-regexp">/([^?&amp;#+]+)=([^?&amp;#+]+)/g</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">replace</span>(reg,<span class="hljs-keyword">function</span>(<span class="hljs-params">$<span class="hljs-number">0</span>,$<span class="hljs-number">1</span>,$<span class="hljs-number">2</span></span>)&#123;<br>            obj[$<span class="hljs-number">1</span>] = $<span class="hljs-number">2</span>;<br>        &#125;)<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>    pro.<span class="hljs-property">queryString</span> = queryString;<br>&#125;(<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>));<br><br><span class="hljs-comment">// 例如 url为 https://www.baidu.com?a=1&amp;b=2</span><br><span class="hljs-comment">// window.location.href.queryString();</span><br><span class="hljs-comment">// &#123;a:1,b:2&#125;</span><br></code></pre></td></tr></table></figure><h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>用于查找在某些内容(但并不包括这些内容)之前或之后的东西，如\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。</p><p>在使用正则表达式时，捕获的内容前后必须是特定的内容，而我们又不想捕获这些特定内容的时候，零宽断言就可以派上用场了。</p><ul><li><p>零宽度正预测先行断言 (?&#x3D;exp)</p></li><li><p>零宽度负预测先行断言 (?!exp)</p></li><li><p>零宽度正回顾后发断言 (?&lt;&#x3D;exp)</p></li><li><p>零宽度负回顾后发断言 (?&lt;!exp)</p></li></ul><p>零宽断言主要有四种格式，这四胞胎看着名字好长，给人一种好复杂好难的感觉，我们还是挨个来看看它们究竟是干什么的吧。</p><p><code>(?=exp)</code> 这个简单理解就是说字符出现的<strong>位置</strong>的右边必须匹配到exp这个表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;i&#x27;m singing and dancing&quot;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/\b(\w+(?=ing\b))/g</span><br><span class="hljs-keyword">var</span> res = str.<span class="hljs-title function_">match</span>(reg);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br><span class="hljs-comment">// [&quot;sing&quot;, &quot;danc&quot;]</span><br><br><br>注意一点，这里说到的是位置，不是字符。<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/a(?=b)c/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res.<span class="hljs-title function_">test</span>(str));  <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 这个看起来似乎是正确的，实际上结果是false</span><br>reg中<span class="hljs-title function_">a</span>(?=b)匹配字符串<span class="hljs-string">&#x27;abc&#x27;</span> 字符串a的右边是b这个匹配没问题,接下来reg中<span class="hljs-title function_">a</span>(?=b)后边的c匹配字符串时是从字符串<span class="hljs-string">&#x27;abc&#x27;</span>中a的后边b的前边的这个位置开始匹配的，<br>这个相当于/ac/匹配<span class="hljs-string">&#x27;abc&#x27;</span>,显然结果是<span class="hljs-literal">false</span>了<br></code></pre></td></tr></table></figure><p><code>(?!exp)</code> 这个就是说字符出现的<strong>位置</strong>的右边不能是exp这个表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;nodejs&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/node(?!js)/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">test</span>(str)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>(?&lt;=exp)</code> 这个就是说字符出现的<strong>位置</strong>的前边是exp这个表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;￥998$888&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(?&lt;=\$)\d+/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">exec</span>(str)) <span class="hljs-comment">//888</span><br><br></code></pre></td></tr></table></figure><p><code>(?&lt;!exp)</code> 这个就是说字符出现的<strong>位置</strong>的前边不能是exp这个表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;￥998$888&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(?&lt;!\$)\d+/</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reg.<span class="hljs-title function_">exec</span>(str)) <span class="hljs-comment">//998</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web前端</tag>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2中的set的使用</title>
    <link href="/2022/01/24/Vue.set()/"/>
    <url>/2022/01/24/Vue.set()/</url>
    
    <content type="html"><![CDATA[<p>前几天在开发一个奇形怪状的页面时，发现了一个问题。某些数据赋值后无法修改，只有更新其它数据时才会更新这些数据。后来经过了一索得知了原因，我的属性是动态添加的，但是Vue不能更新在实例创建后添加的属性。</p><p>用Vue文档原话可能更好理解一些：<code>**如果在实例创建之后添加新的属性到实例上，它不会触发视图更新**</code></p><h2 id="Vue如何追踪变化"><a href="#Vue如何追踪变化" class="headerlink" title="Vue如何追踪变化"></a>Vue如何追踪变化</h2><p>当你把一个普通的JS对象传给vue实例的data选项时，vue将遍历此对象的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter 。</p><p>vue不允许在已经创建的实例上动态添加新的根级响应式属性，不过<strong>可以使用Vue.set()方法将响应式属性添加到嵌套的对象上。</strong></p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>上面说过对象中未经过data域声明的元素，都没有setter属性，也就无法触发视图更新。我出错的代码如下面这种形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">vm.<span class="hljs-property">nowData</span>.<span class="hljs-property">scoreDetails</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          vm.<span class="hljs-property">pointData</span>[item.<span class="hljs-property">qualityClass</span>][item.<span class="hljs-property">qualityPro</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">element, key</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (element.<span class="hljs-property">qualityCode</span> == item.<span class="hljs-property">qualityCode</span>) &#123;<br>              vm.<span class="hljs-property">pointData</span>[item.<span class="hljs-property">qualityClass</span>][item.<span class="hljs-property">qualityPro</span>][key].<span class="hljs-property">isPass</span> = item.<span class="hljs-property">isPass</span><br>              vm.<span class="hljs-property">pointData</span>[item.<span class="hljs-property">qualityClass</span>][item.<span class="hljs-property">qualityPro</span>][key].<span class="hljs-property">problemClassList</span> = item.<span class="hljs-property">problemClassList</span><br>              vm.<span class="hljs-property">pointData</span>[item.<span class="hljs-property">qualityClass</span>][item.<span class="hljs-property">qualityPro</span>][key].<span class="hljs-property">score</span> = item.<span class="hljs-property">score</span><br>            &#125;<br>            vm.<span class="hljs-property">countData</span> = vm.<span class="hljs-property">nowData</span><br>          &#125;)<br>        &#125;)<br></code></pre></td></tr></table></figure><p>因为元素都是循环动态添加进去的，没有办法一开始在data域中声明。这个时候怎么办？这个时候就可以利用set方法了。</p><p>下面是VueApi文档中对Set的描述。</p><h3 id="Vue-set-target-propertyName-x2F-index-value"><a href="#Vue-set-target-propertyName-x2F-index-value" class="headerlink" title="Vue.set( target, propertyName&#x2F;index, value )"></a><a href="https://cn.vuejs.org/v2/api/#Vue-set">Vue.set( target, propertyName&#x2F;index, value )</a></h3><ul><li><strong>参数</strong>：<ul><li><code>&#123;Object | Array&#125; target</code></li><li><code>&#123;string | number&#125; propertyName/index</code></li><li><code>&#123;any&#125; value</code></li></ul></li><li><strong>返回值</strong>：设置的值。</li><li><strong>用法</strong>：<br>  向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 <code>this.myObject.newProperty = &#39;hi&#39;</code>)</li></ul><p>第一个参数是你想添加属性的对象，注意这个对象不能是Vue实例，第二个参数是属性的key值，第三个参数是属性的值。这样添加进去的值就可以触发视图更新。</p><p>修改的代码如下面所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">vm.<span class="hljs-property">nowData</span>.<span class="hljs-property">scoreDetails</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>          vm.<span class="hljs-property">pointData</span>[item.<span class="hljs-property">qualityClass</span>][item.<span class="hljs-property">qualityPro</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">element, key</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (element.<span class="hljs-property">qualityCode</span> == item.<span class="hljs-property">qualityCode</span>) &#123;<br>              vm.$set(vm.<span class="hljs-property">pointData</span>[item.<span class="hljs-property">qualityClass</span>][item.<span class="hljs-property">qualityPro</span>][key], <span class="hljs-string">&#x27;remark&#x27;</span>, item.<span class="hljs-property">remark</span>) <span class="hljs-comment">// 因为质检点的数据是动态生成无法在data域中声明，因此要用set方法赋予作用域</span><br>              vm.$set(vm.<span class="hljs-property">pointData</span>[item.<span class="hljs-property">qualityClass</span>][item.<span class="hljs-property">qualityPro</span>][key], <span class="hljs-string">&#x27;qualityCommon&#x27;</span>, item.<span class="hljs-property">qualityCommon</span>)<br>              vm.$set(vm.<span class="hljs-property">pointData</span>[item.<span class="hljs-property">qualityClass</span>][item.<span class="hljs-property">qualityPro</span>][key], <span class="hljs-string">&#x27;qualityScore&#x27;</span>, item.<span class="hljs-property">qualityScore</span>)<br>            &#125;<br>            vm.<span class="hljs-property">countData</span> = vm.<span class="hljs-property">nowData</span><br>          &#125;)<br>        &#125;)<br></code></pre></td></tr></table></figure><p>还有一个需要注意的点是，这个方法是针对Vue2的，Vue3的底层都改变了，不再有Vue这个实例，在文档中也找不到set这个方法。</p>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript数组遍历</title>
    <link href="/2022/01/24/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86/"/>
    <url>/2022/01/24/%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<p>在平常的开发中，数组的遍历可以说是一个最常用到的功能了。但是在JavaScriot中数组遍历有很多的形式，遇到哪种情况该用哪种形式也是需要要掌握的。最近在开发的时候就踩了一个坑，所以就想总结一下这几种形式。</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><p>可能是最常用可能也最容易被忽略的遍历方式，因为JS有其他花哨的遍历方式，显得最基础的for循环不是那么的易用。循环的例子如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index=<span class="hljs-number">0</span>; index &lt; someArray.<span class="hljs-property">length</span>; index++) &#123;<br> <span class="hljs-keyword">const</span> elem = someArray[index];<br> <span class="hljs-comment">// ···</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是for循环虽然用起来可能没有其他形式方便，但是它的速度是最快的。顺便一提，上面的形式还不是for循环的极限。限免是for循环的优化版，在大数据遍历时比上面的形式更有优势。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index=<span class="hljs-number">0</span>; len=someArray.<span class="hljs-property">length</span>;index &lt; len; index++) &#123;<br> <span class="hljs-keyword">const</span> elem = someArray[index];<br> <span class="hljs-comment">// ···</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这种形式把长度缓存起来，避免重复获得数组的长度。只有数据量较大时才可以明显看出和第一种的区别。</p><p>除了利用数组的长度作为跳出循环的条件，还可以利用判断元素是否为空来跳出循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index=<span class="hljs-number">0</span>; someArray[index]!=<span class="hljs-literal">null</span> ; index++) &#123;<br> <span class="hljs-keyword">const</span> elem = someArray[index];<br> <span class="hljs-comment">// ···</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是实际这种方法的效率还不如第一种方法。这背后有什么原因，以后了解了再说。</p><h2 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for-in 循环"></a>for-in 循环</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> someArray) &#123;<br> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key);<br>&#125;<br></code></pre></td></tr></table></figure><p>for-in也是老资格了，几乎是和for同时出现的方法。它最突出的地方就是作为老方法可以遍历数组和对象。它遍历的是对象的键值或者数组的下标，和for一样。但是它的缺点也是显而易见的，就是太太太慢了，几乎是所有遍历方式中最慢的一种。</p><h2 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for-of 循环"></a>for-of 循环</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;我&#x27;</span>, <span class="hljs-string">&#x27;是&#x27;</span>, <span class="hljs-string">&#x27;谁&#x27;</span>, <span class="hljs-string">&#x27;我&#x27;</span>, <span class="hljs-string">&#x27;在&#x27;</span>, <span class="hljs-string">&#x27;哪&#x27;</span>]<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">of</span> arr) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key)<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然看起来像是老资格，但是for-of循环是在ES6新加的遍历方式，主要可以遍历所有有<code>Iterator</code> 接口的数据格式，比如Map，Set，String，Array等。但是需要注意的是对象Object并没有<code>Iterator</code> 接口，所以for-of循环不能遍历Object。</p><p>比for循环慢，差不多是排到第二的地位。</p><h2 id="forEach-循环"><a href="#forEach-循环" class="headerlink" title="forEach()循环"></a>forEach()循环</h2><p>forEach()是在ES5中新加入的方式，数组有几个元素，这个方法里的回调函数就会调用几次。第一个参数是数组里的元素，第二个参数为数组里元素的索引，第三个参数则是它自己（利用第三个参数可以进行数组去重）。 数组自带的遍历方法，<code>foreach</code>在循环次数未知或者计算起来较复杂的情况下效率比<code>for</code>循环高。</p><p>需要注意的是forEach()方法没有返回值，所以虽然使用<code>return</code>并不会报错，但是一点用也没有，同时也不能使用<code>break</code>和<code>continue</code>跳出整个循环或当前循环的，会报错，但是结合<code>try...catch</code>可以实现跳出循环。</p><p>速度比不上for循环，但是要比for-in要快，介于for-of和for-in之间的速度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br>arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, idnex, array</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)     <span class="hljs-comment">// 1 2 3 4 5 6</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(array)    <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br>&#125;)<br><br><span class="hljs-comment">// 使用try...catch...可以跳出循环</span><br><span class="hljs-keyword">try</span> &#123;<br>   <span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>   arr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>       <span class="hljs-comment">// 跳出条件</span><br>       <span class="hljs-keyword">if</span> (item === <span class="hljs-number">3</span>) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;LoopTerminates&quot;</span>);<br>       &#125;<br>       <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>   &#125;);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">message</span> !== <span class="hljs-string">&quot;LoopTerminates&quot;</span>) <span class="hljs-keyword">throw</span> e;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="map-循环"><a href="#map-循环" class="headerlink" title="map()循环"></a>map()循环</h2><p>forEach()是在原数组进行循环遍历，而map(映射)是克隆一个新的数组来进行遍历，在map中可以使用return来改变新数组的值，但是不能终端遍历。值得一提的是其性能不如forEach()。</p><p>和forEach()一样，不能使用<code>break</code>和<code>continue</code>跳出整个循环或当前循环的，会报错，但是结合<code>try...catch</code>可以实现跳出循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">var</span> ary = [<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">24</span>,<span class="hljs-number">42</span>,<span class="hljs-number">1</span>]; <br><span class="hljs-keyword">var</span> res = ary.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">item,index,ary </span>) &#123; <br>    <span class="hljs-keyword">return</span> item*<span class="hljs-number">10</span>; <br>&#125;) <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res) <span class="hljs-comment">//[ 120, 230, 240, 420, 10 ]</span><br><br><span class="hljs-comment">// 四、使用try...catch...可以跳出循环</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>    arr.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//跳出条件</span><br>        <span class="hljs-keyword">if</span> (item === <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;LoopTerminates&quot;</span>);<br>        &#125;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);<br>        <span class="hljs-keyword">return</span> item<br>    &#125;);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-keyword">if</span> (e.<span class="hljs-property">message</span> !== <span class="hljs-string">&quot;LoopTerminates&quot;</span>) <span class="hljs-keyword">throw</span> e;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><p>从上面总结的遍历方法上可以看出许多方法都不支持对象的遍历，只有for-in是原生支持对象遍历，但是拜此所致，他的效率不是很高。如果我们想用其他遍历方式遍历对象，有没有办法呢？办法还是有的。</p><p><code>Object.keys()</code>就是这样一个方法，它的参数是一个对象，而它返回的值是一个表示给定对象的所有可枚举属性的字符串数组。用人话来说的话就是一个对象键值所组成的数组。</p><p>那这个键值数组不是就可以遍历了吗。主要的遍历方式还是foreach和map这样可以直接遍历值的方式，因为再遍历数组下标再表示方式会有一些麻烦的地方。</p><p>下面是利用foreach()遍历对象的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> person = &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&quot;张三&quot;</span>,<span class="hljs-attr">age</span>:<span class="hljs-number">25</span>,<span class="hljs-attr">address</span>:<span class="hljs-string">&quot;深圳&quot;</span>,<span class="hljs-attr">sex</span>:<span class="hljs-string">&#x27;男&#x27;</span>&#125;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(person).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item) <span class="hljs-comment">// 打印键值</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person[item]) <span class="hljs-comment">//打印键值对应的value</span><br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript事件循环</title>
    <link href="/2022/01/24/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2022/01/24/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>以前在准备面试的时候对事件循环总是一知半解，直到前几天终于在项目中遇到了这个问题，之后通过导师的讲解和我自己的资料查询，我终于对这个概念有了更深层次的了解。下面来写一下我的感悟。</p><h2 id="浏览器拓展"><a href="#浏览器拓展" class="headerlink" title="浏览器拓展"></a>浏览器拓展</h2><p>首先拓展一下，讲一下浏览器的进程处理机制。首先浏览器本身是多进程，这样的处理方式又多种多样的好处，这里先不展开来讲。这里需要知道浏览器的每一个tab页都代表了一个进程，同时浏览器的这个进程中又包含了许多的线程，主要包括GUI 渲染线程（负责渲染页面，解析 HTML，CSS 构成 DOM 树）、JS 引擎线程、事件触发线程、定时器触发线程、http 请求线程等主要线程。</p><h2 id="Javascript的工作线程"><a href="#Javascript的工作线程" class="headerlink" title="Javascript的工作线程"></a>Javascript的工作线程</h2><p>Js执行主要有两个线程，第一个是主线程，这个线程有且仅有一个页面渲染、函数处理都在这个主线程上执行；第二个工作线程，也叫做幕后线程这个线程主要存在于浏览器和Js引擎之中，主要负责异步，文件读取等操作。</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>Js中的所有任务都可以分为同步任务和异步任务。同步任务顾名思义就是按照代码所写的顺序瞬间执行，而异步任务则是按照任务队列机制来运行的。</p><p><img src="/img/eventLoop/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.png"></p><p>上面这个图简单描述了事件循环的过程，当任务进入执行栈中时，首先判断他是同步任务还是异步任务。同步任务进入执行栈立即执行，异步任务则进入任务队列。当所有的同步任务执行完毕之后，再读取任务队列中的微任务，让其进入主线程执行。上述过程的不断重复就是我们说的 Event Loop (事件循环)。</p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>但是整个事件循环还有更复杂的机制，也就是所谓的宏任务和微任务。但是在介绍两者之前，我们再补充一个知识，tick的概念，tick是指事件循环每一次循环的操作，其概述的步骤如下所示。</p><ol><li>在这次循环中选择最新进入队列的宏任务，立即执行一次。</li><li>检测是否存在微任务，如果有立即执行到清空微任务队列。</li><li>更新 render。</li><li>重复执行上述以上步骤。</li></ol><p>这里就要介绍宏任务和微任务的定义是什么了：</p><p>宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I&#x2F;O、UI 交互事件、setImmediate(Node.js 环境)</p><p>微任务主要包含：Promise、MutaionObserver、process.nextTick(Node.js 环境)</p><p>从上面就可以看出宏任务之中包括同步任务和异步任务，这两种分类方式时没有必然联系的，这里也是我以前的一个误区。下面这个图来显示一个tick所操作的流程。需要注意的是执行完最先进入队列的宏任务之后整个tick就结束了，在微任务之后进入的宏任务在此次tick中并不会执行。</p><p><img src="/img/eventLoop/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF_1.png"></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>);<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br></code></pre></td></tr></table></figure><p>答案：script start, script end, promise1, promise2, setTimeout</p><p>这个有两次tick，首先读取代码整体 script 作为第一个宏任务进入主线程，遇到 console.log，输出 script start 。遇到 setTimeout，其回调函数被分发到宏任务 Event Queue 中。遇到 Promise，其 then函数被分到到微任务 Event Queue 中,记为 then1，之后又遇到了 then 函数，将其分到微任务 Event Queue 中，记为 then2。遇到 console.log，输出 script end。</p><p>然后读取任务队列中的任务，setTimeout，then1，then2进入主线程，因为宏任务已经执行完成，所以执行微任务then1和then2，本次tick结束。下一次tick开始，执行setTimeout，没有微任务，第二次tick结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timeout1&#x27;</span>);<br>&#125;, <span class="hljs-number">10</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;timeout2&#x27;</span>), <span class="hljs-number">10</span>);<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;then1&#x27;</span>)<br>&#125;)<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br></code></pre></td></tr></table></figure><p>答案：script start, promise1, script end, then1, timeout1, timeout2</p><p>这题是练习题，具体的执行顺序可以自己想一下，运用上面的知识应该是不成问题的。</p>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java后台环境配置</title>
    <link href="/2021/07/30/%E5%90%8E%E5%8F%B0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/07/30/%E5%90%8E%E5%8F%B0%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>这篇文档是我对后端一个入门的学习，主要是搭建一些环境和框架。不涉及什么原理性的知识。是对自己的知识领域的一个扩充。</p><h2 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h2><p>这台电脑连Java都没有安装，首先要安装java。因为都是一些常规的操作，就简略一点的写。就选自己的电脑系统对应版本，大部分人都是windows 64版本。装linux肯定懂得都懂了。<br><img src="/img/backEndEnvironment/h-1.png" alt="配置图片"><br>之后就按正常的流程安装，和windows装其他软件大体上没什么不同。注意不要有中文目录，安装目录的文件夹必须为空，在安装前新建一个就好了。<br>之后就是万众期待的配置环境变量了。首先windows的我的电脑属性中，界面的样式变了，这个功能微软把这个界面统一都放到了设置中。<br><img src="/img/backEndEnvironment/h-2.png" alt="配置图片"><br>现在是点击右侧的高级系统设置，之后其中找到环境变量的项目。<br><img src="/img/backEndEnvironment/h-3.png" alt="配置图片"><br>选择系统变量，点击新建，输入变量名JAVA_HOME，变量值为JDK的目录所在路径。举个例如的D:\Java\jdk1.8.0_281。如图：<br><img src="/img/backEndEnvironment/h-4.png" alt="配置图片"><br>选择系统变量，找到Path变量，点击编辑，点击新建，输入%JAVA_HOME%\bin，点击确定。之后在cmd中输入javac不报一些没找到就可以了。</p><h2 id="配置数据库mysql"><a href="#配置数据库mysql" class="headerlink" title="配置数据库mysql"></a>配置数据库mysql</h2><p>首先去官网下载mysql的版本，这里还是有点麻烦的，下载要输入账号。这里下载的是解压版的，安装版的暂时只找到了32位的，和64位的配合不是很好。<br><img src="/img/backEndEnvironment/h-5.png" alt="配置图片"><br>下载之后继续解压到你想要安装的目录，之后还要继续配置环境变量。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">MYSQL_HOME：D:\Program</span> <span class="hljs-string">Files\mysql-8.0.26-winx64</span><br><span class="hljs-string">path：%MYSQL_HOME%\bin;</span><br></code></pre></td></tr></table></figure><p>具体的打开方法上面配置java的时候有说，这里就不再详细介绍了。<br>然后用cmd切入mysql安装目录的bin目录，记住要用管理员模式。之后运行这个命令可以初始化root的密码。在新版本的Mysql取消了配置文件，所以新版的MySQL文件夹中没有一些教程中要修改的配置文件。<br>之后把命令也更新了，上次的命令不会在CMD中打印信息，也就不会知道我们的初始密码。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">mysqld</span> <span class="hljs-literal">--</span><span class="hljs-comment">initialize</span> <span class="hljs-literal">--</span><span class="hljs-comment">user=mysql</span> <span class="hljs-literal">--</span><span class="hljs-comment">console</span><br></code></pre></td></tr></table></figure><p><img src="/img/backEndEnvironment/h-6.png" alt="配置图片"><br>最后一行的root@localhost:后面的内容就是你的密码。<br>执行mysqld –install命令，安装mysqld服务；</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">mysqld <span class="hljs-comment">--install</span><br></code></pre></td></tr></table></figure><p>执行net start mysql命令，启动mysql服务；</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">net</span> <span class="hljs-built_in">start</span> mysql<br></code></pre></td></tr></table></figure><p>执行mysql -u root -p命令，连接mysql数据库，输入上述随机生成的密码；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">mysql -u root -<span class="hljs-selector-tag">p</span><br></code></pre></td></tr></table></figure><p>之后利用这个命令修改密码就可以了。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">mysql&gt; <span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;新密码&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="配置tomcat"><a href="#配置tomcat" class="headerlink" title="配置tomcat"></a>配置tomcat</h2><p>首先还是去官网下载你想要的tomcat的一个版本。之后再解压缩到你想要的目录之中。<br><img src="/img/backEndEnvironment/h-7.png" alt="配置图片"><br>之后再去系统那里配置环境变量。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">CATALINA_BASE</span>：D:\Program Files\apache-tomcat-<span class="hljs-number">8</span>.<span class="hljs-number">5</span>.<span class="hljs-number">69</span><br><span class="hljs-attribute">CATALINA_HOME</span>：D:\Program Files\apache-tomcat-<span class="hljs-number">8</span>.<span class="hljs-number">5</span>.<span class="hljs-number">69</span><br><span class="hljs-attribute">path</span>：%CATALINA_HOME%\lib;%CATALINA_HOME%\bin;<br></code></pre></td></tr></table></figure><p>直接在cmd下进入tomcat安装目录下的bin目录，输入启动程序即可,之后就是tomcat的一些常用的命令：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">startup.bat</span>      <span class="hljs-comment">#启动tomcat</span><br><span class="hljs-string">shutdown.bat</span>      <span class="hljs-comment">#关闭tomcat</span><br><span class="hljs-string">service.bat</span> <span class="hljs-string">install</span> <span class="hljs-string">tomcat</span> <span class="hljs-comment">#安装成服务 </span><br></code></pre></td></tr></table></figure><p>运行了第三条命令之后，以后在任意目录就可以用<code>net start tomcat</code>来启动tomcat了。停止命令则是<code>net stop tomcat</code>。</p><h2 id="配置Maven"><a href="#配置Maven" class="headerlink" title="配置Maven"></a>配置Maven</h2><p>最后一步还要配置一下maven，maven就相当于java的包管理工具。用来方便的管理和配置java的包。总之还是先去官网下载。<br>下载地址：<a href="http://maven.apache.org/download.cgi">http://maven.apache.org/download.cgi</a><br>解压后再去系统那里配置环境变量，但是按照普通的那么写<code>%MAVEN_HOME%\bin;</code>这个<code>mvn -v</code>还会报错，所以直接在path中写绝对路径就好了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MAVEN_HOME</span>：D:\Program Files\apache-maven-<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span><br><span class="hljs-attribute">path</span>：D:\Program Files\apache-maven-<span class="hljs-number">3</span>.<span class="hljs-number">8</span>.<span class="hljs-number">1</span>\bin;<br></code></pre></td></tr></table></figure><p>之后可以在cmd中输入<code>mvn -v</code>命令来查看最后安装是否完成。之后还可以配置一下阿里云的镜像，毕竟这种包管理器如果用国外的镜像的话还是比较慢的，进入根目录的conf文件夹，打开setting.xml文件。<br>在<code>&lt;mirrors&gt;</code>标签中加入如下代码即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Nexus aliyun<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span> <br> <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用配置</tag>
      
      <tag>Web后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git的安装与配置教程</title>
    <link href="/2021/07/29/Git%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/07/29/Git%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>git是一个优秀的版本控制软件，自动记录每个版本的变化。方便版本的回退和团队的协作，至少我现在认识到的优点就只有这些。现在最有感受的系统还是分支系统，可以让团队高效的协作。</p><h2 id="git的配置"><a href="#git的配置" class="headerlink" title="git的配置"></a>git的配置</h2><h3 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h3><p>git的下载就是普通的下载，安装的时候可能有一些可需要注意的点就放一个书签来介绍。</p><p><a href="https://blog.csdn.net/Small_Yogurt/article/details/104966939">https://blog.csdn.net/Small_Yogurt&#x2F;article&#x2F;details&#x2F;104966939</a></p><h3 id="git的SSH-Key配置"><a href="#git的SSH-Key配置" class="headerlink" title="git的SSH Key配置"></a>git的SSH Key配置</h3><p>git在配置了SSH Key之后可以不用使用密码，可以直接拉取和推送远程仓库。下面从配置流程开始介绍如可配置SSH Key。</p><p>1、首先配置git的用户名和邮箱，这个是识别上传的用户是谁的标志。其实对之后没什么用，但是必须要做，就先写在这里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Git">git  config  --global  user.name  &quot;user name&quot;<br>git  config  --global  user.email  &quot;your email&quot;<br></code></pre></td></tr></table></figure><p>2、之后就到了真正配置SSH Key的时候，命令如下。具体的图片如下图所示。一般简单处理这个SSH Key就不设密码处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Git">ssh-keygen -t rsa -C &quot;your email&quot;<br></code></pre></td></tr></table></figure><p><img src="/img/git/git1.png"></p><p>3、之后如果密匙文件放在了默认的位置，利用下面的命令来查看密匙的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Git">cat ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p><img src="/img/git/git2.png"></p><p>4、之后相应的远程库把对应的SSH Key输入进去。两者应该就可以不输入密码就可以进行拉取和推送了。</p><p><img src="/img/git/git3.png"></p><p>5、最后可以利用这里的命令来检验是否可以连接到远程长裤。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Git">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p><img src="/img/git/git4.png"></p><h2 id="Sourcetree的安装和使用"><a href="#Sourcetree的安装和使用" class="headerlink" title="Sourcetree的安装和使用"></a>Sourcetree的安装和使用</h2><p>Sourcetree是一款git的GUI操作界面，可以让一些要输入命令行的操作最后得以使用图形界面完成，但是虽然简单直观适合初学者使用，但是复杂操作他可能就心有余而力不足。所以后续的命令行还是要继续学习深化。</p><h3 id="Sourcetree的安装"><a href="#Sourcetree的安装" class="headerlink" title="Sourcetree的安装"></a>Sourcetree的安装</h3><p>这个是安装第一个界面，因为我有科学上网的能力所以可以直接选右边注册一个账号来直接进行注册账号，然后就可以直接进行下一步了。</p><p><img src="/img/git/git5.png"></p><p>然后用按下面这个图片的配置了勾选选项。</p><p><img src="/img/git/git6.png"></p><p>这里会写出本电脑的仓库信息是自动填写的，一般来所是不用管的。</p><p><img src="/img/git/git7.png"></p><p>之后会弹出一个窗口问你配不配置SSHkey，因为我们在上一步git的配置中已经配置过了就不管他。直接一个“否”。</p><p><img src="/img/git/git8.png"></p><p>最后到这里就配置成功了，可喜可贺。</p><p><img src="/img/git/git9.png"></p><h3 id="Sourcetree的配置"><a href="#Sourcetree的配置" class="headerlink" title="Sourcetree的配置"></a>Sourcetree的配置</h3><p>在最开始使用之前，有几项内容还需要配置。首先打开配置中的选项。</p><p><img src="/img/git/git10.png"></p><p>打开后的界面如下图所示，主要有如下几个点需要注意的地方：</p><ul><li><p>默认用户信息：已经是默认填的，一般不用管。</p></li><li><p>SSH客户端配置：这里要设置一下，把SSH客户端选为OpenSSH，他会自动识别key的地址。</p></li><li><p>repo settings：这里的目录是库默认的目录，可以不填，但是填了之后会很方便。以后大家爬取库的时候可以直接从这里爬取。</p></li></ul><p><img src="/img/git/git11.png"></p><h2 id="git的使用"><a href="#git的使用" class="headerlink" title="git的使用"></a>git的使用</h2><p>这里结合git的命令行和Sourcetree的图形化界面来进行项目的拉取，推送等相关操作。</p><h3 id="一次普通的拉取"><a href="#一次普通的拉取" class="headerlink" title="一次普通的拉取"></a>一次普通的拉取</h3><p>这里主要陈述的是在平常项目开始时，如何把项目拉取下来。应该还是比较的简单的一个环节。首先打开在线的github或者其他的页面。这里因为是个人的项目，所以主要以github来举例子。首先复制项目中的git地址。</p><p><img src="/img/git/git12.png"></p><p>然后点击SourceTree的tab的最右边然后再点clone按钮。就可复制当前的项目到你指定的文件夹了。</p><p><img src="/img/git/git13.png"></p><p>或者你可以使用这一步的git命令，来直接在文件夹中克隆这个项目。这样这个项目就出现在了你的电脑之中，你可以查看所有的分支信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Git">git clone git@github.com:Fusn126/my-koa.git<br></code></pre></td></tr></table></figure><p>这个情况默认利用的是主分支，想要使用新的分支。还要使用新的命令和操作。首先，在远端创建一个分支，这里就不放创建远程分支的页面。先点击获取，本地仓库可以直接从远端仓库获取分支更新等信息，然后点击拉取，就可以拉取新分支的内容。然后点击拉取就好了，你可以创建自己的本地分支来切换所对应的本地信息。</p><p><img src="/img/git/git14.png"></p><p>下面来说利用命令行如何来进行切换分支。首先从远端获取更行信息。首先是本来没有本地仓库的情况，那样直接拉取相应分支的仓库就好了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Git">git remote add origin git@github.com:Fusn126/my-koa.git<br></code></pre></td></tr></table></figure><p>如果本来已经有了本地仓库，想要拉取新的分支的话，就需要下面的命令，直接拉取新的分支。注意test是远程的分支名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Git">git fetch origin test<br><br></code></pre></td></tr></table></figure><h3 id="一次普通的提交"><a href="#一次普通的提交" class="headerlink" title="一次普通的提交"></a>一次普通的提交</h3><p>这里示范一次在平时代码时如何提交这个项目，首先要在提交前先抓取分支，因为在实际开发的过程中有很多情况是其他人比你先开发了其他部分，所以要保持你的项目分支是最新的版本。在SourceTree中的操作如下，说实话就是点击上面的拉取然后直接拉取，就完事了。</p><p><img src="/img/git/git15.png"></p><p>但是在这个过程如果你和另一个人都修改了一个文件，那样就可能出现冲突问题。下面这个错误就是冲突问题。首先要提交你的文件，但是这里的提交，只可以提交你修改的文件，如果你没有修改就不要提交，可以忽视或者贮藏（SourceTree特有功能）这些文件。</p><p><img src="/img/git/git16.png"></p><p>SourceTree的提交非常的简单直接按上面的步骤来办就可以直接提交想要的文件。</p><p><img src="/img/git/git17.png"></p><p>命令行则是如下所示。需要注意的点和上面一样，尽量只add你修改的文件，不要一口气add一个文件夹之中的很多文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Git">git add app.js<br>git commit -m &quot;some message&quot;<br><br></code></pre></td></tr></table></figure><p>到这里就会提示，有文件的冲突，提示框非常的显眼，所以应该不需要截图。总之之后的界面如下面所示。</p><p><img src="/img/git/git18.png"></p><p>之后解决从图可以用SourceTree的解决方案，但是我用的一般是vscode直接查看冲突的代码。具体的界面如下图所示。可以直接选择想要哪一个代码保留。选择之后冲突就算是解决了。</p><p><img src="/img/git/git19.png"></p><p>之后就是打开推送选项，选择想要推送的本地分支和远程分支，最后再点击推送就可以了。</p><p><img src="/img/git/git20.png"></p><p>具体的命令行的话如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Git">git push origin my_branch:remote_branch<br></code></pre></td></tr></table></figure><p>总之，大概的内容先写这么多，之后如果还有补充的话。应该会单独在开一个文章，现在这个文章的长度已经是很长了，这篇文章应该以后也会分享，希望能对读到的人产生一点点帮助。</p><h3 id="停止跟踪文件"><a href="#停止跟踪文件" class="headerlink" title="停止跟踪文件"></a>停止跟踪文件</h3><p>在开发中经常遇到这种情况，在项目中的某些文件因为种种原因不想提交的远端的git上去。这是可以利用SourceTree的忽略操作。</p><p><img src="/img/git/git21.png"></p><p>但是这种操作只可以忽略新加入的文件，已经在git文件树中的文件这种方法就是无效的。这时候就要用到大家都很喜欢的命令行了。</p><p>下面两条命令可以把该文件移除git 的文件树，只根据git拉取的样式来提交相关的信息。myconfig指的是文件路径，可以使用相对路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Git">git update-index --skip-worktree -- myconfig //停止跟踪相关文件<br>git update-index --no-skip-worktree -- myconfig //开始跟踪相关文件<br><br></code></pre></td></tr></table></figure><p>下面还有两条相近的的命令，具体的区别还在继续研究之中。现在的理解是这条命令让git认为文件是不变的，既不pull也不进行push。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Git">git update-index --assume-unchanged &quot;/app/*.xml&quot;;//关闭跟踪app目录下后缀为.xml的文件<br>git update-index --assume-unchanged &quot;/app/&quot;;//打开跟踪app目录下的所有文件<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常用配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo的安装与配置教程</title>
    <link href="/2021/07/29/Hexo%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/07/29/Hexo%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。利用这个框架和github pages就可以快速搭建外网可以访问的博客。下面首先来说如何配置。</p><h2 id="github-pages的申请"><a href="#github-pages的申请" class="headerlink" title="github pages的申请"></a>github pages的申请</h2><p>github pages可以让每个用户不用配置服务器就可以创建一个互联网可以访问的页面。但是他的申请本身可能有一些需要注意的地方。</p><p>首先申请github pages就是申请一个github库，申请一个你的用户名.github.io为名字的库。如果名字不是这个可能会报错，实际上我也没有试错过。</p><p>接下来就是一些踩过坑的地方了，首先库的类型要设为Public，Private的github pages功能要收费的。</p><p><img src="/img/hexo/hexo-1.png"></p><p>显示成为这样，你的github pages申请应该就大体完成了。</p><p><img src="/img/hexo/hexo-2.png"></p><h2 id="Hexo的初始化"><a href="#Hexo的初始化" class="headerlink" title="Hexo的初始化"></a>Hexo的初始化</h2><p>Hexo前面的node和npm安装就不说了，我个人已经刻在了DNA之中。然后就是利用npm现在全局环境下安装Hexo。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">npm install -g hexo<br></code></pre></td></tr></table></figure><p>之后利用cmd或者任何终端打开一个你想要放置博客源文件的文件夹，并输入如下命令来操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">hexo init <span class="hljs-comment">//初始化hexo项目，把文件加载到文件夹中</span><br>hexo g <span class="hljs-comment">// 生成编译后的文件，可以直接推送到相应的github上，之后详细介绍</span><br>hexo s <span class="hljs-comment">// 启动服务,可以本地预览你的博客</span><br><br></code></pre></td></tr></table></figure><h2 id="Hexo的主题"><a href="#Hexo的主题" class="headerlink" title="Hexo的主题"></a>Hexo的主题</h2><p>能换主题的时候没人想用默认主题，所以这里就来介绍怎么更换Hexo的主题。这里用的主题是fluid，可能和其他主题的安装方式不同，不可以直接套用。</p><p>Hexo 5.0.0 版本以上，推荐通过 npm 直接安装，进入博客目录执行命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>然后在博客目录下创建 <code>_config.fluid.yml</code>，将主题的 <a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">_config.yml </a>内容复制过去。</p><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>创建成功后修改 <code>/source/about/index.md</code>。直接写关于页的内容。<br>修改后的文件示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">---<br><span class="hljs-attr">title</span>: about<br><span class="hljs-attr">date</span>: <span class="hljs-number">2020</span>-<span class="hljs-number">02</span>-<span class="hljs-number">23</span> <span class="hljs-number">19</span>:<span class="hljs-number">20</span>:<span class="hljs-number">33</span><br><span class="hljs-attr">layout</span>: about<br>---<br><br>这里写关于页的正文，支持 <span class="hljs-title class_">Markdown</span>, <span class="hljs-variable constant_">HTML</span><br></code></pre></td></tr></table></figure><h2 id="Hexo的部署"><a href="#Hexo的部署" class="headerlink" title="Hexo的部署"></a>Hexo的部署</h2><p>上面说了这里会把部署写一下，安装完成主题之后就是部署上去了。首先要用npm安装一个插件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>其次，配置<code>_config.yml</code>中有关deploy的部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:liuxianan/liuxianan.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>最后载直接进行一个命令操作，你的博客就成功上传到github pages上面去了。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-string">hexo</span> <span class="hljs-string">d</span><br></code></pre></td></tr></table></figure><h2 id="Hexo的文章书写"><a href="#Hexo的文章书写" class="headerlink" title="Hexo的文章书写"></a>Hexo的文章书写</h2><p>在Hexo想要上传文章十分的简单，只要利用如下命令就可在快速生成一篇文章。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">文章题目</span><br></code></pre></td></tr></table></figure><p>Hexo这个框架就会自动在根目录下&#x2F;source&#x2F;_posts文件夹下自动生成一个md文件，只要在那里写markdown再保存部署，就可以看到你的文章出现在了线上的博客上了。<br>但是还有一个问题，就是图片引入的问题。在Hexo上的文章不能按照原生markdown的格式来引入，所有图片文件都要放入&#x2F;source&#x2F;img文件夹之下，之后文章中的路径直接写&#x2F;img&#x2F;图片名字.png即可。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">![](<span class="hljs-regexp">/img/</span>图片名字)<br></code></pre></td></tr></table></figure><p>这里稍微扩展一下，如果在fluid主题下想要加入展示图的方法，在开头处按如下格式书写即可，图片格式问题和上面一致。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标题</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">Hexo</span>, <span class="hljs-string">Fluid</span>]<br><span class="hljs-attr">index_img:</span> <span class="hljs-string">/img/example.jpg</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2019-10-10 10:00:00</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><h2 id="Hexo的分类和标签"><a href="#Hexo的分类和标签" class="headerlink" title="Hexo的分类和标签"></a>Hexo的分类和标签</h2><p>虽然分类和标签是两种不同的分类方式，但是两者在Hexo中的配置方式大体相同，这里就来共同介绍一下。首先在终端输入指令。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">page</span> <span class="hljs-string">categories</span> <span class="hljs-comment">#分类</span><br><span class="hljs-string">hexo</span> <span class="hljs-string">new</span> <span class="hljs-string">page</span> <span class="hljs-string">tags</span> <span class="hljs-comment">#标签</span><br></code></pre></td></tr></table></figure><p>他会输出生成的文件所在的目录。根据他给出的目录进行下一步的配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs YAML"><span class="hljs-attr">INFO  Created:</span> <span class="hljs-string">~/Documents/blog/source/categories/index.md</span> <span class="hljs-comment">#分类</span><br><span class="hljs-attr">INFO  Created:</span> <span class="hljs-string">~/Documents/blog/source/tags/index.md</span> <span class="hljs-comment">#标签</span><br></code></pre></td></tr></table></figure><p>之后把两个生成的index.md改为如下的格式。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章分类</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2017-05-27 13:47:40</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">&quot;categories&quot;</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">文章标签</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2017-05-27 13:47:40</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">&quot;tags&quot;</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>之后不做任何操作，他也不会在分类或标签页面生成内容。分类和标签的新增可以直接在文章中添加，在文章中格式如下面所示。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hexo的配置</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2021-07-29 15:18:25</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">Web前端</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">常用配置</span><br><span class="hljs-attr">categories:</span> <br><span class="hljs-bullet">-</span> <span class="hljs-string">技术分享</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web前端</tag>
      
      <tag>常用配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
